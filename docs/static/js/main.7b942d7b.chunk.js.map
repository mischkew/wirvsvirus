{"version":3,"sources":["simulationWorker.js","utils.js","branding.js","components/Edges.jsx","components/StationMarker.jsx","simulation.js","layers/agents.js","components/AgentsLayer.jsx","components/ProgressLayer.jsx","components/SimulationMap.jsx","testUtils.js","App.jsx","serviceWorker.js","index.js"],"names":["addMethods","methods","module","exports","w","Worker","name","getPosition","positionObject","L","latLng","lat","lng","getEdges","stations","edges","seen","Set","buildHash","station_id","other_station_id","addEdge","edge","add","start","end","push","isMarked","has","Object","entries","id","station","next_stops","other_id","TRANSPARENT_RGBA","HEALTHY_RGB","INFECTED_RGB","RECOVERED_RGB","Edges","polylineStations","filter","type","map","polylineStreets","Fragment","Polyline","positions","color","weight","StationMarker","position","CircleMarker","center","radius","fillOpacity","AgentsLayer","Layer","extend","options","simulation","onUpdate","count","day","time","infectedCount","recoveredCount","simulationSpeed","initialize","Util","setOptions","this","Error","_stations","onAdd","_map","_canvas","_initCanvas","_regl","_initRegl","_agents","_simulation","_initSimulation","pane","getPane","appendChild","_panes","overlayPane","on","_reset","_resize","_render","canvas","DomUtil","create","originProp","testProp","style","size","getSize","width","x","height","y","zIndex","animated","zoomAnimation","Browser","any3d","addClass","context","getContext","regl","e","worker","SimulationWorker","addEventListener","event","data","console","error","destroySimulation","terminate","setupSimulation","runSimulation","_draw","_buildDraw","_frameLoop","frame","clear","mapSize","length","agents","startCoordinates","agent","point","latLngToContainerPoint","endCoordinates","Math","floor","reduce","acc","frag","vert","attributes","startCoordinate","endCoordinate","isWaiting","health","uniforms","pointWidth","healthyColor","infectedColor","recoveredColor","mapWidth","mapHeight","deltaTime","travelTime","globalDay","globalTime","primitive","newSize","topLeft","containerPointToLayerPoint","setPosition","_restart","updateStations","updateOptions","simulationOptions","_AgentsLayer","fromProps","toProps","leafletElement","MapLayer","withLeaflet","ProgressLayer","className","children","defaultProps","top","bottom","left","right","SimulationMap","box","zoom","minZoom","maxZoom","isValid","toBBoxString","contains","useState","simulationProgress","setSimulationProgress","Map","maxBounds","TileLayer","attribution","url","key","renderStationMarkers","minutes","hours","hourMinutes","hoursString","hourMinutesString","toHours","testAgentsTemplate","recovery_time","infection_probability","schedule","probability","value","variance","stay_until","berlinCenter","berlincBox","latLngBounds","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.7b942d7b.chunk.js","sourcesContent":["\n\t\t\t\tvar addMethods = require(\"../node_modules/workerize-loader/dist/rpc-wrapper.js\")\n\t\t\t\tvar methods = [\"setupSimulation\",\"runSimulation\",\"destroySimulation\"]\n\t\t\t\tmodule.exports = function() {\n\t\t\t\t\tvar w = new Worker(__webpack_public_path__ + \"3e93649547b1e5ff1b78.worker.js\", { name: \"[hash].worker.js\" })\n\t\t\t\t\taddMethods(w, methods)\n\t\t\t\t\t\n\t\t\t\t\treturn w\n\t\t\t\t}\n\t\t\t","import L from 'leaflet';\n\n/**\n * Convert an objects lat and lng fields into a Leaflet L.LatLng object.\n * @param {any} positionObject An object containing lat and lng properties.\n * @returns {L.LatLng}\n */\nexport function getPosition(positionObject) {\n  return L.latLng(positionObject.lat, positionObject.lng);\n}\n\n/**\n * Traverse the graph of stations and streets and return each edge only once.\n * @param {object} stations Stations graph - Object containing a key per\n *   station, position as lat, lng and a list of next_stops. See\n *   `data-design/stations.json`.\n * @returns {Array<{start: string, end: string}>} List of edges given as object\n *   of start and end, whereby start and end are the station ids.\n */\nexport function getEdges(stations) {\n  const edges = [];\n  const seen = new Set();\n\n  function buildHash(station_id, other_station_id) {\n    return `start-${station_id}-end-${other_station_id}`;\n  }\n\n  function buildEdge(station_id, other_station_id) {\n    return { start: station_id, end: other_station_id };\n  }\n\n  function addEdge(edge) {\n    seen.add(buildHash(edge.start, edge.end));\n    edges.push(edge);\n  }\n\n  function isMarked(edge) {\n    return (\n      seen.has(buildHash(edge.start, edge.end)) ||\n      seen.has(buildHash(edge.end, edge.start))\n    );\n  }\n\n  for (let [id, station] of Object.entries(stations)) {\n    for (let other_id of station.next_stops) {\n      const edge = buildEdge(id, other_id);\n      if (!isMarked(edge)) {\n        addEdge(edge);\n      }\n    }\n  }\n\n  return edges;\n}\n","export const TRANSPARENT_RGBA = [0, 0, 0, 0];\n\n// Color Palette: https://colorhunt.co/palette/177866\nexport const BLUE_DARKER = '#204051';\nexport const BLUE_DARK = '#3b6978';\nexport const BLUE_LIGHT = '#84a9ac';\nexport const BLUE_LIGHTER = '#cae8d5';\n\n// Color Palette: https://colorhunt.co/palette/177314\nexport const HEALTHY_RGB = [0, 255, 0]; // [43, 88, 12];\nexport const INFECTED_RGB = [255, 0, 0];\nexport const RECOVERED_RGB = [0, 0, 255];\n\n// Color Palette: https://colorhunt.co/palette/176667\nexport const RECOVERED = '#be79df';\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { getPosition, getEdges } from '../utils';\nimport { Polyline } from 'react-leaflet';\nimport { BLUE_DARK, BLUE_DARKER } from '../branding';\n\nexport default function Edges({ stations }) {\n  const polylineStations = getEdges(stations)\n    .filter(({ start, end }) => {\n      return (\n        stations[start].type === 'station' && stations[end].type === 'station'\n      );\n    })\n    .map(({ start, end }) => {\n      return [getPosition(stations[start]), getPosition(stations[end])];\n    });\n  const polylineStreets = getEdges(stations)\n    .filter(({ start, end }) => {\n      return (\n        stations[start].type === 'street' || stations[end].type === 'street'\n      );\n    })\n    .map(({ start, end }) => {\n      return [getPosition(stations[start]), getPosition(stations[end])];\n    });\n  return (\n    <React.Fragment>\n      <Polyline positions={polylineStreets} color={BLUE_DARKER} weight={2} />\n      <Polyline positions={polylineStations} color={BLUE_DARK} weight={3} />\n    </React.Fragment>\n  );\n}\n\nEdges.propTypes = {\n  stations: PropTypes.object.isRequired,\n};\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { CircleMarker } from 'react-leaflet';\nimport L from 'leaflet';\nimport { getPosition } from '../utils';\nimport { BLUE_DARK } from '../branding';\n\nexport default function StationMarker({ position }) {\n  return (\n    <CircleMarker\n      center={position}\n      radius={6}\n      weight={3}\n      color={BLUE_DARK}\n      fillOpacity={0.9}\n    />\n  );\n}\n\nStationMarker.propTypes = {\n  position: PropTypes.instanceOf(L.LatLng).isRequired,\n};\n\nexport function renderStationMarkers(stations) {\n  return Object.entries(stations)\n    .filter(([id, station]) => {\n      return station.type === 'station';\n    })\n    .map(([id, station]) => {\n      return <StationMarker key={id} position={getPosition(station)} />;\n    });\n}\n","import PriorityQueue from 'js-priority-queue';\nimport { generatePathFromPredecessorMap } from './pathGeneration';\nimport { INFECTED, RECOVERED, HEALTHY } from './actorGeneration';\n\nconst logging = false;\nexport const WAITING = 0;\nexport const TRANSITIONING = 1;\nexport const TRAVEL_TIME = 10;\nexport const TICKS_PER_MINUTE = 1;\nexport const INFECTION_SPEED = 0.5;\nexport const RECOVERY_TIME = 2; // days\n\nexport const MINUTES_PER_DAY = 24 * 60;\n\nexport function timeToMinutes(time) {\n  return Math.floor(time / 100) * 60 + (time % 100);\n}\n\nexport function minutesToTime(min) {\n  return Math.floor(min / 60) * 100 + (min % 60);\n}\n\nfunction compareDateTime(a, b) {\n  if (a.day < b.day) {\n    return -1;\n  }\n\n  if (a.day > b.day) {\n    return 1;\n  }\n\n  return a.time - b.time;\n}\n\nclass TimeQueue {\n  constructor() {\n    this.queue = this.travel_queue = new PriorityQueue({\n      comparator: compareDateTime,\n      strategy: PriorityQueue.BinaryHeapStrategy,\n    });\n  }\n\n  enqueue({ item, day, time }) {\n    this.queue.queue({ item, day, time });\n  }\n\n  dequeueExpired(day, time, callback) {\n    while (\n      this.queue.length > 0 &&\n      this.queue.peek().day === day &&\n      this.queue.peek().time <= time\n    ) {\n      const item = this.queue.dequeue().item;\n\n      callback(item);\n    }\n  }\n}\n\nexport class Actor {\n  constructor({\n    status,\n    schedule,\n    current_station,\n    current_schedule,\n    state,\n    path,\n    path_position,\n    sim,\n  }) {\n    this.status = status;\n    this.schedule = schedule;\n    this.current_station = current_station;\n    this.current_schedule = current_schedule;\n    this.state = state;\n    this.path = path;\n    this.path_position = path_position;\n    this.sim = sim;\n  }\n\n  arriveAtNextPathStop() {\n    this.state = WAITING;\n\n    this.advancePath({\n      onNext: () => {\n        this.sim.actorWaitsForDeparture({\n          actor: this,\n          station: this.current_station,\n          destination: this.nextPathStop(),\n        });\n      },\n      onArrivedAtDestination: () => {\n        this.arriveAtScheduleLocation();\n      },\n    });\n  }\n\n  arriveAtScheduleLocation() {\n    if (this.currentScheduleExpired()) {\n      this.advanceSchedule();\n    }\n    this.sim.scheduleWait(\n      this,\n      this.schedule[this.current_schedule].stay_until\n    );\n  }\n\n  currentScheduleExpired() {\n    // check if the current schedule entry's stay_until is in the past\n    // the first entry (residence) can never expire\n    // meaning the actor will always wait at home if nothing else is left on the schedule\n    return (\n      this.current_schedule !== 0 &&\n      this.schedule[this.current_schedule].time < this.sim.time\n    );\n  }\n\n  stayFinished() {\n    this.advanceSchedule();\n\n    this.preparePath({\n      onAlreadyThere: () => {\n        this.arriveAtScheduleLocation();\n      },\n      onPrepared: () => {\n        this.sim.actorWaitsForDeparture({\n          actor: this,\n          station: this.current_station,\n          destination: this.nextPathStop(),\n        });\n      },\n    });\n  }\n\n  _cycleSchedule() {\n    if (this.current_schedule === this.schedule.length - 1) {\n      this.current_schedule = 0;\n    } else {\n      this.current_schedule += 1;\n    }\n  }\n\n  advanceSchedule() {\n    // advance the schedule to the next valid position\n    // if at last entry, go back home (schedule 0)\n    this._cycleSchedule();\n\n    // skip any entries, which have a time in the past (cannot go there anymore)\n    while (this.currentScheduleExpired()) {\n      this._cycleSchedule();\n    }\n  }\n\n  advancePath({ onNext, onArrivedAtDestination }) {\n    this.path_position += 1;\n    this.current_station = this.path[this.path_position];\n\n    if (this.path_position === this.path.length - 1) {\n      // arrived at destination\n      this.path = null;\n      this.path_position = null;\n      onArrivedAtDestination();\n    } else {\n      // go to next station in path\n      onNext();\n    }\n  }\n\n  preparePath({ onAlreadyThere, onPrepared }) {\n    const destination = this.schedule[this.current_schedule].station;\n    if (destination === this.current_station) {\n      onAlreadyThere();\n      return;\n    }\n    this.path = generatePathFromPredecessorMap(\n      this.sim.predecessorMaps[this.current_station],\n      destination\n    );\n    this.path_position = 0;\n    onPrepared();\n  }\n\n  nextPathStop() {\n    if (this.path === null || this.path_position === this.path.length - 1) {\n      return null;\n    }\n    return this.path[this.path_position + 1];\n  }\n\n  tryInfect(chance) {\n    return this.status === HEALTHY && chance > Math.random();\n  }\n}\n\nfunction buildActors(actorsData, sim) {\n  return actorsData.map(actorData => {\n    return new Actor({ ...actorData, sim });\n  });\n}\n\nexport class Simulator {\n  constructor(stations, actorsData, predecessorMaps) {\n    this.stations = stations;\n    this.actors = buildActors(actorsData, this);\n    this.predecessorMaps = predecessorMaps;\n    this.time = 6 * 60;\n    this.day = 0;\n    this.travel_queue = new TimeQueue();\n    this.idle_queue = new TimeQueue();\n    this.recover_queue = new TimeQueue();\n    this.station_queues = Object.fromEntries(\n      Object.entries(stations).map(([key, station]) => {\n        const next_stops = Object.fromEntries(\n          station.next_stops.map(station => {\n            return [station, []];\n          })\n        );\n        return [key, next_stops];\n      })\n    );\n    this.tick = 0;\n\n    this.arrivalCallback = () => {};\n    this.finishStayCallback = () => {};\n    this.waitCallback = () => {};\n  }\n\n  startActors() {\n    this.actors.forEach(actor => {\n      actor.arriveAtScheduleLocation();\n    });\n  }\n\n  onNextDay() {\n    this.day += 1;\n  }\n\n  stepTime() {\n    this.tick = this.tick + 1;\n    let ticked = false;\n    if (this.tick >= TICKS_PER_MINUTE) {\n      this.time = this.time + 1;\n      this.tick = 0;\n      ticked = true;\n    }\n    if (this.time === MINUTES_PER_DAY) {\n      this.time = 0;\n      this.onNextDay();\n    }\n    return ticked;\n  }\n\n  actorWaitsForDeparture({ actor, station, destination }) {\n    this.station_queues[station][destination].push(actor);\n  }\n\n  scheduleWait(actor, until) {\n    const time = timeToMinutes(until);\n    const queueItem = {\n      item: actor,\n      day: this.day + (time <= this.time),\n      time,\n    };\n    this.idle_queue.enqueue(queueItem);\n\n    this.waitCallback(actor, queueItem.day, queueItem.time);\n  }\n\n  infect(actor) {\n    actor.status = INFECTED;\n    this.recover_queue.enqueue({\n      item: actor,\n      day: this.day + RECOVERY_TIME,\n      time: this.time,\n    });\n  }\n\n  handleInfectionTrigger(actors) {\n    const infected = actors.reduce((acc, actor) => {\n      return acc + (actor.status === INFECTED ? 1 : 0);\n    }, 0);\n\n    let infection_chance = (infected / actors.length) * INFECTION_SPEED;\n    if (infection_chance > 1) {\n      infection_chance = 1;\n    }\n\n    if (logging && infection_chance > 0) {\n      console.log(\n        `Spreading the infection on ${actors.length} people with chance ${infection_chance}`\n      );\n    }\n\n    actors.forEach(actor => {\n      if (actor.tryInfect(infection_chance)) {\n        this.infect(actor);\n      }\n    });\n  }\n\n  step() {\n    const ticked = this.stepTime();\n    if (!ticked) {\n      return this.actors;\n    }\n\n    this.idle_queue.dequeueExpired(this.day, this.time, actor => {\n      actor.stayFinished();\n      this.finishStayCallback(\n        actor,\n        actor.current_station,\n        actor.nextPathStop(),\n        actor.schedule[actor.current_schedule].name\n      );\n    });\n\n    this.travel_queue.dequeueExpired(this.day, this.time, arrivedActors => {\n      arrivedActors.forEach(actor => {\n        actor.arriveAtNextPathStop();\n        this.arrivalCallback(actor);\n      });\n    });\n\n    this.recover_queue.dequeueExpired(this.day, this.time, healedActor => {\n      healedActor.status = RECOVERED;\n    });\n\n    if (this.time % TRAVEL_TIME === 0) {\n      Object.entries(this.station_queues).forEach(([station, nextStations]) => {\n        Object.entries(nextStations).forEach(([next, actors]) => {\n          if (actors.length > 0) {\n            actors.forEach(actor => {\n              actor.state = TRANSITIONING;\n            });\n            this.travel_queue.enqueue({\n              day:\n                this.day +\n                Math.floor((this.time + TRAVEL_TIME) / MINUTES_PER_DAY),\n              time: (this.time + TRAVEL_TIME) % MINUTES_PER_DAY,\n              item: actors,\n            });\n            this.handleInfectionTrigger(actors);\n            nextStations[next] = [];\n          }\n        });\n      });\n    }\n\n    return this.actors;\n  }\n}\n","import L, { Util } from 'leaflet';\nimport regl from 'regl';\nimport { TRAVEL_TIME } from '../simulation';\nimport {\n  TRANSPARENT_RGBA,\n  HEALTHY_RGB,\n  INFECTED_RGB,\n  RECOVERED_RGB,\n} from '../branding';\nimport SimulationWorker from 'workerize-loader!../simulationWorker'; // eslint-disable-line import/no-webpack-loader-syntax\n\n//\n// Leaflet Layer\n//\n\nL.AgentsLayer = L.Layer.extend({\n  options: {\n    // will be passed on instantiation\n    // contains simulation settings from the user\n    // see `data-design/actor.json`\n    simulation: null,\n\n    // a callback which is called everytime the agent loop updated, i.e. can be\n    // used to display simulation progress outside of the layer via react\n    onUpdate: ({ count, day, time, infectedCount, recoveredCount }) => {},\n\n    // speed of the simulation in ticks. Minimum 1. The highter the number, the\n    // faster the simulation runs. This parameter basically tells the renderer\n    // to only update every `simulationSpeed` ticks.\n    simulationSpeed: 1,\n  },\n\n  initialize: function(stations, options) {\n    Util.setOptions(this, options);\n    if (this.options.simulation === null) {\n      throw new Error('Simulation options must be set!');\n    }\n\n    this._stations = stations;\n  },\n\n  onAdd: function(map) {\n    this._map = map;\n    this._canvas = this._initCanvas(map);\n    this._regl = this._initRegl(this._canvas);\n\n    // this is the agents buffer, which will get upated by the worker loop\n    this._agents = [];\n    this._simulation = this._initSimulation();\n\n    if (this.options.pane) {\n      this.getPane().appendChild(this._canvas);\n    } else {\n      map._panes.overlayPane.appendChild(this._canvas);\n    }\n\n    map.on('move', this._reset, this);\n    map.on('resize', this._resize, this);\n\n    this._reset();\n    this._render();\n  },\n\n  _initCanvas: function() {\n    const canvas = L.DomUtil.create('canvas', 'webgl-canvas leaflet-layer');\n\n    // place the canvas on top of the map, in the middle of the screen\n    const originProp = L.DomUtil.testProp([\n      'transformOrigin',\n      'WebkitTransformOrigin',\n      'msTransformOrigin',\n    ]);\n    canvas.style[originProp] = '50% 50%';\n\n    // make the canvas cover the whole map\n    const size = this._map.getSize();\n    canvas.width = size.x;\n    canvas.height = size.y;\n    canvas.style.position = 'absolute';\n\n    // leaflet renders svg on z-index 200, so we put the canvas on top\n    canvas.style.zIndex = 201;\n\n    var animated = this._map.options.zoomAnimation && L.Browser.any3d;\n    L.DomUtil.addClass(\n      canvas,\n      'leaflet-zoom-' + (animated ? 'animated' : 'hide')\n    );\n\n    return canvas;\n  },\n\n  _initRegl: function(canvas) {\n    try {\n      const context =\n        canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n      return regl(context);\n    } catch (e) {\n      throw new Error('WebGL is not supported in your browser.');\n    }\n  },\n\n  _initSimulation: function() {\n    const worker = SimulationWorker();\n\n    // fill the agents buffer so the rendering loop can access the simulation\n    // progress\n    worker.addEventListener('message', event => {\n      if (event.data && event.data.type && event.data.type === 'RPC') {\n        return;\n      }\n      // console.time('event parse');\n      this._agents = event.data;\n      // console.timeEnd('event parse');\n    });\n\n    // kill the worker when an error happened\n    worker.addEventListener('error', event => {\n      console.error(event);\n      worker.destroySimulation();\n      worker.terminate();\n    });\n\n    // launch the worker\n    worker.setupSimulation(this.options.simulation, this._stations);\n    worker.runSimulation(this.options.simulationSpeed);\n\n    return worker;\n  },\n\n  _render: function() {\n    this._draw = this._buildDraw();\n\n    this._frameLoop = this._regl.frame(() => {\n      this._regl.clear({\n        color: TRANSPARENT_RGBA,\n      });\n\n      this._draw();\n    });\n  },\n\n  _buildDraw: function() {\n    const mapSize = this._map.getSize();\n\n    return function draw() {\n      // console.time('render');\n      if (this._agents.length !== 3) {\n        // no agents computed yet, must have 3 element according to protocol\n        return;\n      }\n\n      // console.time('coords');\n      const [day, time, agents] = this._agents;\n      const startCoordinates = agents.map(agent => {\n        // according to protocol the latlng values of the start position are\n        // stored in field 0\n        const point = this._map.latLngToContainerPoint(agent[0]);\n        return [point.x, point.y];\n      });\n      const endCoordinates = agents.map(agent => {\n        // according to protocol the latlng values of the end position are\n        // stored in field 1\n        const point = this._map.latLngToContainerPoint(agent[1]);\n        return [point.x, point.y];\n      });\n\n      this.options.onUpdate({\n        day,\n        time: Math.floor(time),\n        count: this.options.simulation.count,\n        infectedCount: agents.reduce((acc, agent) => {\n          return acc + (agent[3] === 1 ? 1 : 0);\n        }, 0),\n        recoveredCount: agents.reduce((acc, agent) => {\n          return acc + (agent[3] === 2 ? 1 : 0);\n        }, 0),\n      });\n      // console.timeEnd('coords');\n\n      // console.time('regl');\n      this._regl({\n        frag: `\n          precision lowp float;\n\n          // input RGB color with values between 0 and 255\n          varying vec3 frag_color;\n\n          void main() {\n            // colors need to be mapped between 0 and 1\n            gl_FragColor = vec4(frag_color / 255.0, 1.0);\n          }\n      `,\n        vert: `\n          precision lowp float;\n\n          attribute vec2 startCoordinate;\n          attribute vec2 endCoordinate;\n\n          // \"boolean\" flag if the agent is currently waiting. As no boolean\n          // values exist in GLSL, we pass a float.\n          attribute float isWaiting;\n          attribute float health;\n\n          uniform float pointWidth;\n          uniform vec3 healthyColor;\n          uniform vec3 infectedColor;\n          uniform vec3 recoveredColor;\n          uniform float mapWidth;\n          uniform float mapHeight;\n\n          // delta of the rendering time since last update\n          uniform float deltaTime;\n\n          // time progress of the simulation\n          uniform float globalTime;\n          uniform float globalDay;\n\n          // the amount of time it takes to go from start to end in simulation time\n          uniform float travelTime;\n\n          varying vec3 frag_color;\n\n          // We assume that each start and end position is equi-distanced in the\n          // graph and takes the same amount of time for each agent to reach.\n          // Every trafficInterval ticks, an agent can travel from one station\n          // to the next, which in turn takes trafficInterval ticks. Based on\n          // these assumption we can render the position of the agents on the\n          // route.\n          vec2 positionOnRoute() {\n            float remainder = mod(globalTime, travelTime);\n            float travelProgressFactor = 0.0;\n\n            // we are not waiting, so interpolate the point between start and end\n            if (isWaiting < 0.5) {\n              travelProgressFactor = remainder / travelTime;\n            }\n\n            return startCoordinate + travelProgressFactor * (endCoordinate - startCoordinate);\n          }\n\n          // helper function to transform from pixel space to normalized device\n          // coordinates (NDC) in NDC (0,0) is the middle, (-1, 1) is the top\n          // left and (1, -1) is the bottom right.\n          vec2 normalizeCoords(vec2 position) {\n            // read in the positions into x and y vars\n            float x = position[0];\n            float y = position[1];\n\n            return vec2(\n              2.0 * ((x / mapWidth) - 0.5),\n              -2.0 * ((y / mapHeight) - 0.5)\n            );\n          }\n\n          void main() {\n            vec3 color = healthyColor;\n            if (health > 0.5) {\n              color = infectedColor;\n            }\n            if (health > 1.5) {\n              color = recoveredColor;\n            }\n            frag_color = color;\n\n            if(isWaiting > 0.5) {\n              gl_PointSize = 3.0;\n            }\n            else {\n              gl_PointSize = pointWidth;\n            }\n\n            vec4 pos = vec4(normalizeCoords(positionOnRoute()), 0.0, 1.0);\n            if (pos.x < -1.0 || pos.x > 1.0 || pos.y < -1.0 || pos.y > 1.0) {\n              return;\n            }\n            gl_Position = pos;\n          }\n      `,\n        attributes: {\n          startCoordinate: startCoordinates,\n          endCoordinate: endCoordinates,\n          // according to proctol, the isWaiting flag is stored as a float in\n          // agent field 2\n          isWaiting: agents.map(agent => agent[2]),\n          health: agents.map(agent => agent[3]),\n        },\n        uniforms: {\n          pointWidth: 5.0,\n          healthyColor: HEALTHY_RGB,\n          infectedColor: INFECTED_RGB,\n          recoveredColor: RECOVERED_RGB,\n          mapWidth: mapSize.x,\n          mapHeight: mapSize.y,\n          deltaTime: this._regl.context('deltaTime'),\n          travelTime: TRAVEL_TIME,\n          globalDay: day,\n          globalTime: time,\n        },\n        count: startCoordinates.length,\n        primitive: 'points',\n      })();\n      // console.timeEnd('regl');\n\n      // console.timeEnd('render');\n    };\n  },\n\n  _resize: function(event) {\n    const size = event.newSize;\n\n    this._canvas.width = size.x;\n    this._canvas.height = size.y;\n\n    this._reset();\n  },\n\n  _reset: function() {\n    const topLeft = this._map.containerPointToLayerPoint([0, 0]);\n    L.DomUtil.setPosition(this._canvas, topLeft);\n  },\n\n  _restart: function() {\n    if (this._simulation) {\n      this._simulation.destroySimulation();\n      this._simulation.terminate();\n    }\n\n    this._simulation = this._initSimulation();\n    this._draw = this._buildDraw();\n  },\n\n  updateStations: function(stations) {\n    this._stations = stations;\n    this._restart();\n  },\n\n  updateOptions: function(options) {\n    Util.setOptions(this, options);\n    this._restart();\n  },\n});\n\nexport default L.AgentsLayer;\n","import { MapLayer, withLeaflet } from 'react-leaflet';\nimport _AgentsLayer from '../layers/agents';\n\nclass AgentsLayer extends MapLayer {\n  createLeafletElement({ stations, simulationOptions, onUpdate }) {\n    return new _AgentsLayer(stations, {\n      simulation: simulationOptions,\n      onUpdate,\n    });\n  }\n\n  updateLeafletElement(fromProps, toProps) {\n    if (fromProps.stations !== toProps.stations) {\n      this.leafletElement.updateStations(toProps.stations);\n    }\n\n    if (fromProps.simulationOptions !== toProps.simulationOptions) {\n      this.leafletElement.updateOptions(toProps.simulationOptions);\n    }\n  }\n}\n\nexport default withLeaflet(AgentsLayer);\n","import React from 'react';\n\nexport default function ProgressLayer({ className, style, children }) {\n  return (\n    <div className={`custom-pane ${className}`} style={style}>\n      {children}\n    </div>\n  );\n}\n\nProgressLayer.defaultProps = {\n  style: {\n    position: 'absolute',\n    zIndex: 900, // above the MapPane\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n  },\n};\n","import React, { useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { Map, TileLayer } from 'react-leaflet';\nimport L from 'leaflet';\nimport Edges from './Edges';\nimport { renderStationMarkers } from './StationMarker';\nimport { getPosition } from '../utils';\nimport AgentsLayer from './AgentsLayer';\nimport ProgressLayer from './ProgressLayer';\n\n// required leaflet styles\nimport 'leaflet/dist/leaflet.css';\nimport './SimulationMap.css';\n\nfunction toHours(minutes) {\n  const hours = Math.floor(minutes / 60);\n  const hourMinutes = minutes - hours * 60;\n\n  let hoursString = `${hours}`;\n  if (hoursString.length === 1) {\n    hoursString = '0' + hoursString;\n  }\n\n  let hourMinutesString = `${hourMinutes}`;\n  if (hourMinutesString.length === 1) {\n    hourMinutesString = '0' + hourMinutesString;\n  }\n\n  return `${hoursString}:${hourMinutesString}`;\n}\n\nexport default function SimulationMap({\n  position,\n  box,\n  zoom,\n  minZoom,\n  maxZoom,\n  stations,\n  simulationOptions,\n}) {\n  if (!box.isValid()) {\n    throw new Error(`Bounding box is not valid: ${box.toBBoxString()}`);\n  }\n\n  if (!box.contains(position)) {\n    throw new Error(\n      `Map center ${position} is not inside the bounding box ${box.toBBoxString()}`\n    );\n  }\n\n  for (let [id, station] of Object.entries(stations)) {\n    const position = getPosition(station);\n    if (!box.contains(position)) {\n      throw new Error(\n        `Station ${id} at positiion ${position} is not contained in bounding box ${box.toBBoxString()}`\n      );\n    }\n  }\n\n  const [simulationProgress, setSimulationProgress] = useState({\n    count: 0,\n    day: 0,\n    time: 0,\n    infectedCount: 0,\n    recoveredCount: 0,\n  });\n\n  return (\n    <Map\n      id=\"simulation-map\"\n      center={position}\n      zoom={zoom}\n      minZoom={minZoom}\n      maxZoom={maxZoom}\n      maxBounds={box}\n    >\n      <TileLayer\n        attribution='&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n        url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n      />\n      <Edges stations={stations} />\n      {renderStationMarkers(stations)}\n      <AgentsLayer\n        stations={stations}\n        simulationOptions={simulationOptions}\n        onUpdate={setSimulationProgress}\n      />\n      <ProgressLayer className=\"simulation-progress\">\n        <div>\n          <span>\n            Infected: {simulationProgress.infectedCount} of{' '}\n            {simulationProgress.count - simulationProgress.recoveredCount}\n          </span>\n          <span>\n            Day: {simulationProgress.day} ({toHours(simulationProgress.time)})\n          </span>\n          <span>Recovered: {simulationProgress.recoveredCount}</span>\n        </div>\n      </ProgressLayer>\n    </Map>\n  );\n}\n\nSimulationMap.propTypes = {\n  position: PropTypes.instanceOf(L.LatLng).isRequired,\n  box: PropTypes.instanceOf(L.LatLngBounds),\n  zoom: PropTypes.number,\n  minZoom: PropTypes.number,\n  maxZoom: PropTypes.number,\n  stations: PropTypes.object.isRequired,\n  simulationOptions: PropTypes.object.isRequired,\n};\n\nSimulationMap.defaultProps = {\n  zoom: 12,\n  minZoom: 11,\n  maxZoom: 13,\n  box: null,\n};\n","export const testStations = {\n  BHF_TEGEL: {\n    name: 'Tegel',\n    lat: 52.57,\n    lng: 13.4,\n    next_stops: ['BHF_FRIEDRICHSTRASSE'],\n  },\n  BHF_SUDKREUZ: {\n    name: 'Sudkreuz',\n    lat: 52.53,\n    lng: 13.4,\n    next_stops: ['BHF_FRIEDRICHSTRASSE'],\n  },\n  BHF_GRIEBNITZSEE: {\n    name: 'Griebnitzsee',\n    lat: 52.5,\n    lng: 13.43,\n    next_stops: ['BHF_CHARLOTTENBURG'],\n  },\n  BHF_FRIEDRICHSTRASSE: {\n    name: 'Friedrichstrasse',\n    lat: 52.51,\n    lng: 13.39,\n    next_stops: ['BHF_CHARLOTTENBURG', 'BHF_TEGEL', 'BHF_SUDKREUZ'],\n  },\n  BHF_CHARLOTTENBURG: {\n    name: 'Charlottenburg',\n    lat: 52.454,\n    lng: 13.45,\n    next_stops: ['BHF_FRIEDRICHSTRASSE', 'BHF_GRIEBNITZSEE'],\n  },\n};\n\nexport const testAgentsTemplate = {\n  count: 1000,\n  recovery_time: 10,\n  infection_probability: 0.2,\n  schedule: [\n    {\n      name: 'residence',\n      probability: {\n        value: 1,\n        variance: 0,\n      },\n      stay_until: {\n        time: 800,\n        variance: 300,\n      },\n    },\n    {\n      name: 'work',\n      probability: {\n        value: 1,\n        variance: 0,\n      },\n      stay_until: {\n        time: 1500,\n        variance: 300,\n      },\n    },\n    {\n      name: 'groceries',\n      probability: {\n        value: 0.3,\n        variance: 0,\n      },\n      stay_until: {\n        time: 1900,\n        variance: 200,\n      },\n    },\n    {\n      name: 'evening',\n      probability: {\n        value: 0.1,\n        variance: 0,\n      },\n      stay_until: {\n        time: 2200,\n        variance: 150,\n      },\n    },\n    {\n      name: 'night',\n      probability: {\n        value: 0.05,\n        variance: 0,\n      },\n      stay_until: {\n        time: 200,\n        variance: 100,\n      },\n    },\n  ],\n};\n\n// no evening / nighttime activities\n// 25% of people work\nexport const quarantineTemplate = {\n  count: 1000,\n  recovery_time: 10,\n  infection_probability: 0.2,\n  schedule: [\n    {\n      name: 'residence',\n      probability: {\n        value: 1,\n        variance: 0,\n      },\n      stay_until: {\n        time: 800,\n        variance: 300,\n      },\n    },\n    {\n      name: 'work',\n      probability: {\n        value: 0.25,\n        variance: 0,\n      },\n      stay_until: {\n        time: 1500,\n        variance: 300,\n      },\n    },\n    {\n      name: 'groceries',\n      probability: {\n        value: 0.3,\n        variance: 0,\n      },\n      stay_until: {\n        time: 1900,\n        variance: 200,\n      },\n    },\n  ],\n};\n","import React from 'react';\nimport SimulationMap from './components/SimulationMap';\nimport L from 'leaflet';\nimport './App.css';\nimport { stations } from './assets/stations.json';\nimport { testAgentsTemplate } from './testUtils';\n\nconst berlinCenter = L.latLng(52.52885, 13.40456);\nconst berlincBox = L.latLngBounds(L.latLng(52.4, 13.1), L.latLng(52.6, 13.7));\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SimulationMap\n        maxZoom={20}\n        position={berlinCenter}\n        box={berlincBox}\n        stations={stations}\n        simulationOptions={testAgentsTemplate}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}